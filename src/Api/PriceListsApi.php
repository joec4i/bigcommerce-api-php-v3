<?php
/**
 * PriceListsApi
 * PHP version 5
 *
 * @category Class
 * @package  BigCommerce\Api\V3
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * BigCommerce API
 *
 * A Swagger Document for the BigCommmerce v3 API.
 *
 * OpenAPI spec version: 3.0.0b
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.7
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BigCommerce\Api\V3\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BigCommerce\Api\V3\ApiException;
use BigCommerce\Api\V3\Configuration;
use BigCommerce\Api\V3\HeaderSelector;
use BigCommerce\Api\V3\ObjectSerializer;

/**
 * PriceListsApi Class Doc Comment
 *
 * @category Class
 * @package  BigCommerce\Api\V3
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PriceListsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createPriceList
     *
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPost $price_list A BigCommerce &#x60;PriceList&#x60; object. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceListResponse
     */
    public function createPriceList($price_list)
    {
        list($response) = $this->createPriceListWithHttpInfo($price_list);
        return $response;
    }

    /**
     * Operation createPriceListWithHttpInfo
     *
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPost $price_list A BigCommerce &#x60;PriceList&#x60; object. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPriceListWithHttpInfo($price_list)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse';
        $request = $this->createPriceListRequest($price_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPriceListAsync
     *
     * 
     *
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPost $price_list A BigCommerce &#x60;PriceList&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPriceListAsync($price_list)
    {
        return $this->createPriceListAsyncWithHttpInfo($price_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPriceListAsyncWithHttpInfo
     *
     * 
     *
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPost $price_list A BigCommerce &#x60;PriceList&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPriceListAsyncWithHttpInfo($price_list)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse';
        $request = $this->createPriceListRequest($price_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPriceList'
     *
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPost $price_list A BigCommerce &#x60;PriceList&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPriceListRequest($price_list)
    {
        // verify the required parameter 'price_list' is set
        if ($price_list === null || (is_array($price_list) && count($price_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list when calling createPriceList'
            );
        }

        $resourcePath = '/pricelists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($price_list)) {
            $_tempBody = $price_list;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePriceList
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePriceList($price_list_id)
    {
        $this->deletePriceListWithHttpInfo($price_list_id);
    }

    /**
     * Operation deletePriceListWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePriceListWithHttpInfo($price_list_id)
    {
        $returnType = '';
        $request = $this->deletePriceListRequest($price_list_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePriceListAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListAsync($price_list_id)
    {
        return $this->deletePriceListAsyncWithHttpInfo($price_list_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePriceListAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListAsyncWithHttpInfo($price_list_id)
    {
        $returnType = '';
        $request = $this->deletePriceListRequest($price_list_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePriceList'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePriceListRequest($price_list_id)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling deletePriceList'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePriceListRecord
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePriceListRecord($price_list_id, $variant_id, $currency_code)
    {
        $this->deletePriceListRecordWithHttpInfo($price_list_id, $variant_id, $currency_code);
    }

    /**
     * Operation deletePriceListRecordWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePriceListRecordWithHttpInfo($price_list_id, $variant_id, $currency_code)
    {
        $returnType = '';
        $request = $this->deletePriceListRecordRequest($price_list_id, $variant_id, $currency_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePriceListRecordAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListRecordAsync($price_list_id, $variant_id, $currency_code)
    {
        return $this->deletePriceListRecordAsyncWithHttpInfo($price_list_id, $variant_id, $currency_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePriceListRecordAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListRecordAsyncWithHttpInfo($price_list_id, $variant_id, $currency_code)
    {
        $returnType = '';
        $request = $this->deletePriceListRecordRequest($price_list_id, $variant_id, $currency_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePriceListRecord'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePriceListRecordRequest($price_list_id, $variant_id, $currency_code)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling deletePriceListRecord'
            );
        }
        // verify the required parameter 'variant_id' is set
        if ($variant_id === null || (is_array($variant_id) && count($variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variant_id when calling deletePriceListRecord'
            );
        }
        // verify the required parameter 'currency_code' is set
        if ($currency_code === null || (is_array($currency_code) && count($currency_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_code when calling deletePriceListRecord'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records/{variant_id}/{currency_code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }
        // path params
        if ($variant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variant_id' . '}',
                ObjectSerializer::toPathValue($variant_id),
                $resourcePath
            );
        }
        // path params
        if ($currency_code !== null) {
            $resourcePath = str_replace(
                '{' . 'currency_code' . '}',
                ObjectSerializer::toPathValue($currency_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePriceListRecordsByFilter
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\NoContent
     */
    public function deletePriceListRecordsByFilter($price_list_id, $variant_id = null)
    {
        list($response) = $this->deletePriceListRecordsByFilterWithHttpInfo($price_list_id, $variant_id);
        return $response;
    }

    /**
     * Operation deletePriceListRecordsByFilterWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\NoContent, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePriceListRecordsByFilterWithHttpInfo($price_list_id, $variant_id = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\NoContent';
        $request = $this->deletePriceListRecordsByFilterRequest($price_list_id, $variant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\NoContent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePriceListRecordsByFilterAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListRecordsByFilterAsync($price_list_id, $variant_id = null)
    {
        return $this->deletePriceListRecordsByFilterAsyncWithHttpInfo($price_list_id, $variant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePriceListRecordsByFilterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListRecordsByFilterAsyncWithHttpInfo($price_list_id, $variant_id = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\NoContent';
        $request = $this->deletePriceListRecordsByFilterRequest($price_list_id, $variant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePriceListRecordsByFilter'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePriceListRecordsByFilterRequest($price_list_id, $variant_id = null)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling deletePriceListRecordsByFilter'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variant_id !== null) {
            $queryParams['variant_id'] = ObjectSerializer::toQueryValue($variant_id);
        }

        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePriceListRecordsByVariantId
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePriceListRecordsByVariantId($price_list_id, $variant_id)
    {
        $this->deletePriceListRecordsByVariantIdWithHttpInfo($price_list_id, $variant_id);
    }

    /**
     * Operation deletePriceListRecordsByVariantIdWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePriceListRecordsByVariantIdWithHttpInfo($price_list_id, $variant_id)
    {
        $returnType = '';
        $request = $this->deletePriceListRecordsByVariantIdRequest($price_list_id, $variant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePriceListRecordsByVariantIdAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListRecordsByVariantIdAsync($price_list_id, $variant_id)
    {
        return $this->deletePriceListRecordsByVariantIdAsyncWithHttpInfo($price_list_id, $variant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePriceListRecordsByVariantIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListRecordsByVariantIdAsyncWithHttpInfo($price_list_id, $variant_id)
    {
        $returnType = '';
        $request = $this->deletePriceListRecordsByVariantIdRequest($price_list_id, $variant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePriceListRecordsByVariantId'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePriceListRecordsByVariantIdRequest($price_list_id, $variant_id)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling deletePriceListRecordsByVariantId'
            );
        }
        // verify the required parameter 'variant_id' is set
        if ($variant_id === null || (is_array($variant_id) && count($variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variant_id when calling deletePriceListRecordsByVariantId'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records/{variant_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }
        // path params
        if ($variant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variant_id' . '}',
                ObjectSerializer::toPathValue($variant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePriceListsByFilter
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePriceListsByFilter($id = null, $name = null)
    {
        $this->deletePriceListsByFilterWithHttpInfo($id, $name);
    }

    /**
     * Operation deletePriceListsByFilterWithHttpInfo
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePriceListsByFilterWithHttpInfo($id = null, $name = null)
    {
        $returnType = '';
        $request = $this->deletePriceListsByFilterRequest($id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePriceListsByFilterAsync
     *
     * 
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListsByFilterAsync($id = null, $name = null)
    {
        return $this->deletePriceListsByFilterAsyncWithHttpInfo($id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePriceListsByFilterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePriceListsByFilterAsyncWithHttpInfo($id = null, $name = null)
    {
        $returnType = '';
        $request = $this->deletePriceListsByFilterRequest($id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePriceListsByFilter'
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePriceListsByFilterRequest($id = null, $name = null)
    {

        $resourcePath = '/pricelists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPriceList
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceListResponse
     */
    public function getPriceList($price_list_id)
    {
        list($response) = $this->getPriceListWithHttpInfo($price_list_id);
        return $response;
    }

    /**
     * Operation getPriceListWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPriceListWithHttpInfo($price_list_id)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse';
        $request = $this->getPriceListRequest($price_list_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPriceListAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListAsync($price_list_id)
    {
        return $this->getPriceListAsyncWithHttpInfo($price_list_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPriceListAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListAsyncWithHttpInfo($price_list_id)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse';
        $request = $this->getPriceListRequest($price_list_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPriceList'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPriceListRequest($price_list_id)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling getPriceList'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPriceListCollection
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceListCollectionResponse
     */
    public function getPriceListCollection($id = null, $name = null, $date_created = null, $date_modified = null, $page = null, $limit = null)
    {
        list($response) = $this->getPriceListCollectionWithHttpInfo($id, $name, $date_created, $date_modified, $page, $limit);
        return $response;
    }

    /**
     * Operation getPriceListCollectionWithHttpInfo
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceListCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPriceListCollectionWithHttpInfo($id = null, $name = null, $date_created = null, $date_modified = null, $page = null, $limit = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListCollectionResponse';
        $request = $this->getPriceListCollectionRequest($id, $name, $date_created, $date_modified, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceListCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPriceListCollectionAsync
     *
     * 
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListCollectionAsync($id = null, $name = null, $date_created = null, $date_modified = null, $page = null, $limit = null)
    {
        return $this->getPriceListCollectionAsyncWithHttpInfo($id, $name, $date_created, $date_modified, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPriceListCollectionAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListCollectionAsyncWithHttpInfo($id = null, $name = null, $date_created = null, $date_modified = null, $page = null, $limit = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListCollectionResponse';
        $request = $this->getPriceListCollectionRequest($id, $name, $date_created, $date_modified, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPriceListCollection'
     *
     * @param  int $id Filter items by id. (optional)
     * @param  string $name Filter items by name. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPriceListCollectionRequest($id = null, $name = null, $date_created = null, $date_modified = null, $page = null, $limit = null)
    {

        $resourcePath = '/pricelists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($date_created !== null) {
            $queryParams['date_created'] = ObjectSerializer::toQueryValue($date_created);
        }
        // query params
        if ($date_modified !== null) {
            $queryParams['date_modified'] = ObjectSerializer::toQueryValue($date_modified);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPriceListRecord
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse
     */
    public function getPriceListRecord($price_list_id, $variant_id, $currency_code, $include = null)
    {
        list($response) = $this->getPriceListRecordWithHttpInfo($price_list_id, $variant_id, $currency_code, $include);
        return $response;
    }

    /**
     * Operation getPriceListRecordWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPriceListRecordWithHttpInfo($price_list_id, $variant_id, $currency_code, $include = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse';
        $request = $this->getPriceListRecordRequest($price_list_id, $variant_id, $currency_code, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPriceListRecordAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListRecordAsync($price_list_id, $variant_id, $currency_code, $include = null)
    {
        return $this->getPriceListRecordAsyncWithHttpInfo($price_list_id, $variant_id, $currency_code, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPriceListRecordAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListRecordAsyncWithHttpInfo($price_list_id, $variant_id, $currency_code, $include = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse';
        $request = $this->getPriceListRecordRequest($price_list_id, $variant_id, $currency_code, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPriceListRecord'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPriceListRecordRequest($price_list_id, $variant_id, $currency_code, $include = null)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling getPriceListRecord'
            );
        }
        // verify the required parameter 'variant_id' is set
        if ($variant_id === null || (is_array($variant_id) && count($variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variant_id when calling getPriceListRecord'
            );
        }
        // verify the required parameter 'currency_code' is set
        if ($currency_code === null || (is_array($currency_code) && count($currency_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_code when calling getPriceListRecord'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records/{variant_id}/{currency_code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }

        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }
        // path params
        if ($variant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variant_id' . '}',
                ObjectSerializer::toPathValue($variant_id),
                $resourcePath
            );
        }
        // path params
        if ($currency_code !== null) {
            $resourcePath = str_replace(
                '{' . 'currency_code' . '}',
                ObjectSerializer::toPathValue($currency_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPriceListRecordCollection
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     * @param  string $product_id A comma-separated list of ids of &#x60;Product&#x60;s whose prices were requested. (optional)
     * @param  string $currency Filter items by currency. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     * @param  float $price Filter items by price. (optional)
     * @param  float $sale_price Filter items by sale_price. (optional)
     * @param  float $retail_price Filter items by retail_price. (optional)
     * @param  float $map_price Filter items by map_price. (optional)
     * @param  float $calculated_price Filter items by calculated_price. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  string $sku Filter items by sku. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse
     */
    public function getPriceListRecordCollection($price_list_id, $variant_id = null, $product_id = null, $currency = null, $page = null, $limit = null, $include = null, $price = null, $sale_price = null, $retail_price = null, $map_price = null, $calculated_price = null, $date_created = null, $date_modified = null, $sku = null)
    {
        list($response) = $this->getPriceListRecordCollectionWithHttpInfo($price_list_id, $variant_id, $product_id, $currency, $page, $limit, $include, $price, $sale_price, $retail_price, $map_price, $calculated_price, $date_created, $date_modified, $sku);
        return $response;
    }

    /**
     * Operation getPriceListRecordCollectionWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     * @param  string $product_id A comma-separated list of ids of &#x60;Product&#x60;s whose prices were requested. (optional)
     * @param  string $currency Filter items by currency. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     * @param  float $price Filter items by price. (optional)
     * @param  float $sale_price Filter items by sale_price. (optional)
     * @param  float $retail_price Filter items by retail_price. (optional)
     * @param  float $map_price Filter items by map_price. (optional)
     * @param  float $calculated_price Filter items by calculated_price. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  string $sku Filter items by sku. (optional)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPriceListRecordCollectionWithHttpInfo($price_list_id, $variant_id = null, $product_id = null, $currency = null, $page = null, $limit = null, $include = null, $price = null, $sale_price = null, $retail_price = null, $map_price = null, $calculated_price = null, $date_created = null, $date_modified = null, $sku = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse';
        $request = $this->getPriceListRecordCollectionRequest($price_list_id, $variant_id, $product_id, $currency, $page, $limit, $include, $price, $sale_price, $retail_price, $map_price, $calculated_price, $date_created, $date_modified, $sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPriceListRecordCollectionAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     * @param  string $product_id A comma-separated list of ids of &#x60;Product&#x60;s whose prices were requested. (optional)
     * @param  string $currency Filter items by currency. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     * @param  float $price Filter items by price. (optional)
     * @param  float $sale_price Filter items by sale_price. (optional)
     * @param  float $retail_price Filter items by retail_price. (optional)
     * @param  float $map_price Filter items by map_price. (optional)
     * @param  float $calculated_price Filter items by calculated_price. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  string $sku Filter items by sku. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListRecordCollectionAsync($price_list_id, $variant_id = null, $product_id = null, $currency = null, $page = null, $limit = null, $include = null, $price = null, $sale_price = null, $retail_price = null, $map_price = null, $calculated_price = null, $date_created = null, $date_modified = null, $sku = null)
    {
        return $this->getPriceListRecordCollectionAsyncWithHttpInfo($price_list_id, $variant_id, $product_id, $currency, $page, $limit, $include, $price, $sale_price, $retail_price, $map_price, $calculated_price, $date_created, $date_modified, $sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPriceListRecordCollectionAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     * @param  string $product_id A comma-separated list of ids of &#x60;Product&#x60;s whose prices were requested. (optional)
     * @param  string $currency Filter items by currency. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     * @param  float $price Filter items by price. (optional)
     * @param  float $sale_price Filter items by sale_price. (optional)
     * @param  float $retail_price Filter items by retail_price. (optional)
     * @param  float $map_price Filter items by map_price. (optional)
     * @param  float $calculated_price Filter items by calculated_price. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  string $sku Filter items by sku. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListRecordCollectionAsyncWithHttpInfo($price_list_id, $variant_id = null, $product_id = null, $currency = null, $page = null, $limit = null, $include = null, $price = null, $sale_price = null, $retail_price = null, $map_price = null, $calculated_price = null, $date_created = null, $date_modified = null, $sku = null)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse';
        $request = $this->getPriceListRecordCollectionRequest($price_list_id, $variant_id, $product_id, $currency, $page, $limit, $include, $price, $sale_price, $retail_price, $map_price, $calculated_price, $date_created, $date_modified, $sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPriceListRecordCollection'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id The ID of the &#x60;Variant&#x60; whose prices were requested. (optional)
     * @param  string $product_id A comma-separated list of ids of &#x60;Product&#x60;s whose prices were requested. (optional)
     * @param  string $currency Filter items by currency. (optional)
     * @param  int $page Specifies the page number in a limited (paginated) list of products. (optional)
     * @param  int $limit Controls the number of items per page in a limited (paginated) list of products. (optional)
     * @param  string $include Sub-resources to include on a price record, in a comma-separated list. Valid expansions currently include &#x60;bulk_pricing_tiers&#x60; and &#x60;sku&#x60;.  Other valies will be ignored. (optional)
     * @param  float $price Filter items by price. (optional)
     * @param  float $sale_price Filter items by sale_price. (optional)
     * @param  float $retail_price Filter items by retail_price. (optional)
     * @param  float $map_price Filter items by map_price. (optional)
     * @param  float $calculated_price Filter items by calculated_price. (optional)
     * @param  \DateTime $date_created Filter items by date_created. (optional)
     * @param  \DateTime $date_modified Filter items by date_modified. (optional)
     * @param  string $sku Filter items by sku. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPriceListRecordCollectionRequest($price_list_id, $variant_id = null, $product_id = null, $currency = null, $page = null, $limit = null, $include = null, $price = null, $sale_price = null, $retail_price = null, $map_price = null, $calculated_price = null, $date_created = null, $date_modified = null, $sku = null)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling getPriceListRecordCollection'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variant_id !== null) {
            $queryParams['variant_id'] = ObjectSerializer::toQueryValue($variant_id);
        }
        // query params
        if ($product_id !== null) {
            $queryParams['product_id'] = ObjectSerializer::toQueryValue($product_id);
        }
        // query params
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // query params
        if ($price !== null) {
            $queryParams['price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($sale_price !== null) {
            $queryParams['sale_price'] = ObjectSerializer::toQueryValue($sale_price);
        }
        // query params
        if ($retail_price !== null) {
            $queryParams['retail_price'] = ObjectSerializer::toQueryValue($retail_price);
        }
        // query params
        if ($map_price !== null) {
            $queryParams['map_price'] = ObjectSerializer::toQueryValue($map_price);
        }
        // query params
        if ($calculated_price !== null) {
            $queryParams['calculated_price'] = ObjectSerializer::toQueryValue($calculated_price);
        }
        // query params
        if ($date_created !== null) {
            $queryParams['date_created'] = ObjectSerializer::toQueryValue($date_created);
        }
        // query params
        if ($date_modified !== null) {
            $queryParams['date_modified'] = ObjectSerializer::toQueryValue($date_modified);
        }
        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku);
        }

        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPriceListRecordsByVariantId
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse
     */
    public function getPriceListRecordsByVariantId($price_list_id, $variant_id)
    {
        list($response) = $this->getPriceListRecordsByVariantIdWithHttpInfo($price_list_id, $variant_id);
        return $response;
    }

    /**
     * Operation getPriceListRecordsByVariantIdWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPriceListRecordsByVariantIdWithHttpInfo($price_list_id, $variant_id)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse';
        $request = $this->getPriceListRecordsByVariantIdRequest($price_list_id, $variant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPriceListRecordsByVariantIdAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListRecordsByVariantIdAsync($price_list_id, $variant_id)
    {
        return $this->getPriceListRecordsByVariantIdAsyncWithHttpInfo($price_list_id, $variant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPriceListRecordsByVariantIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceListRecordsByVariantIdAsyncWithHttpInfo($price_list_id, $variant_id)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionResponse';
        $request = $this->getPriceListRecordsByVariantIdRequest($price_list_id, $variant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPriceListRecordsByVariantId'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPriceListRecordsByVariantIdRequest($price_list_id, $variant_id)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling getPriceListRecordsByVariantId'
            );
        }
        // verify the required parameter 'variant_id' is set
        if ($variant_id === null || (is_array($variant_id) && count($variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variant_id when calling getPriceListRecordsByVariantId'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records/{variant_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }
        // path params
        if ($variant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variant_id' . '}',
                ObjectSerializer::toPathValue($variant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPriceListRecord
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordPut $price_record A BigCommerce &#x60;Price Record&#x60; object. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse
     */
    public function setPriceListRecord($price_list_id, $variant_id, $currency_code, $price_record)
    {
        list($response) = $this->setPriceListRecordWithHttpInfo($price_list_id, $variant_id, $currency_code, $price_record);
        return $response;
    }

    /**
     * Operation setPriceListRecordWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordPut $price_record A BigCommerce &#x60;Price Record&#x60; object. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setPriceListRecordWithHttpInfo($price_list_id, $variant_id, $currency_code, $price_record)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse';
        $request = $this->setPriceListRecordRequest($price_list_id, $variant_id, $currency_code, $price_record);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\NotFound',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setPriceListRecordAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordPut $price_record A BigCommerce &#x60;Price Record&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPriceListRecordAsync($price_list_id, $variant_id, $currency_code, $price_record)
    {
        return $this->setPriceListRecordAsyncWithHttpInfo($price_list_id, $variant_id, $currency_code, $price_record)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPriceListRecordAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordPut $price_record A BigCommerce &#x60;Price Record&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPriceListRecordAsyncWithHttpInfo($price_list_id, $variant_id, $currency_code, $price_record)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceRecordResponse';
        $request = $this->setPriceListRecordRequest($price_list_id, $variant_id, $currency_code, $price_record);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPriceListRecord'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  int $variant_id ID of the variant on a product, or on an associated Price List Record. (required)
     * @param  string $currency_code The currency code associated with the price record being acted upon. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordPut $price_record A BigCommerce &#x60;Price Record&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setPriceListRecordRequest($price_list_id, $variant_id, $currency_code, $price_record)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling setPriceListRecord'
            );
        }
        // verify the required parameter 'variant_id' is set
        if ($variant_id === null || (is_array($variant_id) && count($variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variant_id when calling setPriceListRecord'
            );
        }
        // verify the required parameter 'currency_code' is set
        if ($currency_code === null || (is_array($currency_code) && count($currency_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_code when calling setPriceListRecord'
            );
        }
        // verify the required parameter 'price_record' is set
        if ($price_record === null || (is_array($price_record) && count($price_record) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_record when calling setPriceListRecord'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records/{variant_id}/{currency_code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }
        // path params
        if ($variant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variant_id' . '}',
                ObjectSerializer::toPathValue($variant_id),
                $resourcePath
            );
        }
        // path params
        if ($currency_code !== null) {
            $resourcePath = str_replace(
                '{' . 'currency_code' . '}',
                ObjectSerializer::toPathValue($currency_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($price_record)) {
            $_tempBody = $price_record;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPriceListRecordCollection
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionPut $price_record_batch A BigCommerce &#x60;Price Record&#x60; request. (required)
     * @param  int $x_strict_mode Header that determines whether the Batch API operates in strict mode or not.  Strict mode will reject the entire request if any item in the batch has an error. (optional, default to 0)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\SuccessBatchResponse
     */
    public function setPriceListRecordCollection($price_list_id, $price_record_batch, $x_strict_mode = '0')
    {
        list($response) = $this->setPriceListRecordCollectionWithHttpInfo($price_list_id, $price_record_batch, $x_strict_mode);
        return $response;
    }

    /**
     * Operation setPriceListRecordCollectionWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionPut $price_record_batch A BigCommerce &#x60;Price Record&#x60; request. (required)
     * @param  int $x_strict_mode Header that determines whether the Batch API operates in strict mode or not.  Strict mode will reject the entire request if any item in the batch has an error. (optional, default to 0)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\SuccessBatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setPriceListRecordCollectionWithHttpInfo($price_list_id, $price_record_batch, $x_strict_mode = '0')
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\SuccessBatchResponse';
        $request = $this->setPriceListRecordCollectionRequest($price_list_id, $price_record_batch, $x_strict_mode);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\SuccessBatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceRecordBatchErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setPriceListRecordCollectionAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionPut $price_record_batch A BigCommerce &#x60;Price Record&#x60; request. (required)
     * @param  int $x_strict_mode Header that determines whether the Batch API operates in strict mode or not.  Strict mode will reject the entire request if any item in the batch has an error. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPriceListRecordCollectionAsync($price_list_id, $price_record_batch, $x_strict_mode = '0')
    {
        return $this->setPriceListRecordCollectionAsyncWithHttpInfo($price_list_id, $price_record_batch, $x_strict_mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPriceListRecordCollectionAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionPut $price_record_batch A BigCommerce &#x60;Price Record&#x60; request. (required)
     * @param  int $x_strict_mode Header that determines whether the Batch API operates in strict mode or not.  Strict mode will reject the entire request if any item in the batch has an error. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPriceListRecordCollectionAsyncWithHttpInfo($price_list_id, $price_record_batch, $x_strict_mode = '0')
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\SuccessBatchResponse';
        $request = $this->setPriceListRecordCollectionRequest($price_list_id, $price_record_batch, $x_strict_mode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPriceListRecordCollection'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceRecordCollectionPut $price_record_batch A BigCommerce &#x60;Price Record&#x60; request. (required)
     * @param  int $x_strict_mode Header that determines whether the Batch API operates in strict mode or not.  Strict mode will reject the entire request if any item in the batch has an error. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setPriceListRecordCollectionRequest($price_list_id, $price_record_batch, $x_strict_mode = '0')
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling setPriceListRecordCollection'
            );
        }
        // verify the required parameter 'price_record_batch' is set
        if ($price_record_batch === null || (is_array($price_record_batch) && count($price_record_batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_record_batch when calling setPriceListRecordCollection'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}/records';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_strict_mode !== null) {
            $headerParams['X-Strict-Mode'] = ObjectSerializer::toHeaderValue($x_strict_mode);
        }

        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($price_record_batch)) {
            $_tempBody = $price_record_batch;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePriceList
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPut $price_list A BigCommerce &#x60;Price List&#x60; object. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BigCommerce\Api\V3\Model\Swagger\PriceListResponse
     */
    public function updatePriceList($price_list_id, $price_list)
    {
        list($response) = $this->updatePriceListWithHttpInfo($price_list_id, $price_list);
        return $response;
    }

    /**
     * Operation updatePriceListWithHttpInfo
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPut $price_list A BigCommerce &#x60;Price List&#x60; object. (required)
     *
     * @throws \BigCommerce\Api\V3\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BigCommerce\Api\V3\Model\Swagger\PriceListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePriceListWithHttpInfo($price_list_id, $price_list)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse';
        $request = $this->updatePriceListRequest($price_list_id, $price_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\NotFound',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BigCommerce\Api\V3\Model\Swagger\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePriceListAsync
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPut $price_list A BigCommerce &#x60;Price List&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePriceListAsync($price_list_id, $price_list)
    {
        return $this->updatePriceListAsyncWithHttpInfo($price_list_id, $price_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePriceListAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPut $price_list A BigCommerce &#x60;Price List&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePriceListAsyncWithHttpInfo($price_list_id, $price_list)
    {
        $returnType = '\BigCommerce\Api\V3\Model\Swagger\PriceListResponse';
        $request = $this->updatePriceListRequest($price_list_id, $price_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePriceList'
     *
     * @param  int $price_list_id The ID of the &#x60;Price List&#x60; requested. (required)
     * @param  \BigCommerce\Api\V3\Model\Swagger\PriceListPut $price_list A BigCommerce &#x60;Price List&#x60; object. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePriceListRequest($price_list_id, $price_list)
    {
        // verify the required parameter 'price_list_id' is set
        if ($price_list_id === null || (is_array($price_list_id) && count($price_list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list_id when calling updatePriceList'
            );
        }
        // verify the required parameter 'price_list' is set
        if ($price_list === null || (is_array($price_list) && count($price_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_list when calling updatePriceList'
            );
        }

        $resourcePath = '/pricelists/{price_list_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($price_list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'price_list_id' . '}',
                ObjectSerializer::toPathValue($price_list_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($price_list)) {
            $_tempBody = $price_list;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
